\subsubsection{aursec --- Architecture}
We designed \texttt{aursec} to be a good UNIX citizen:

\begin{itemize}
\item Modular design \\ multiple small tools doing one thing and doing it well
\item Adherence to the universal interface \cite{Salus:1994} \\
  Work on streams of text on \texttt{stdin} and \texttt{stdout}
\item Written in Bash and using existing tools where possible
\item Maximize concurrency using a pipeline
\end{itemize}

\texttt{aursec} builds a pipeline of two other tools, \texttt{aursec-hash} and \texttt{aursec-verify-hashes}, which produces lines containing the id and hash of a package as well as the hash representing the current consensus on the blockchain and the number of times that hash was submitted.
It then inserts itself into that pipeline and iterates over the lines of items using a \emph{while-read} loop and traverses the aforementioned state machine for each item.

This architecture has several advantages: It is straightforward to understand because it follows standard UNIX patterns, which also makes it very maintainable.
The free 3-level parallelism gained by the pipeline is a very useful advantage in itself, but even more so because all 3 tools are primarily I/O-bound: \texttt{aursec-hash} reads and hashes lots of files, \texttt{aursec-verify-hashes} constantly queries (and waits for) the blockchain, and \texttt{aursec} tends to spend much time waiting for user input.
Thus, the concurrency is even more important because it allows work to continue in the background while \texttt{aursec} waits for the user. Indeed, the background tasks tend to be finished in most practical situations before the user has had time to inspect the second or third warning. % NOTE: Maybe add an anecdote about how this is similarly good to the bulk-verification of sources in aursync vs yaourt?

\subsubsection{aursec-hash}
\texttt{aursec-hash} has the simple task of producing an ID (\texttt{\$pkgname-\$pkgver-\$pkgrel}) and a hash from \texttt{PKGBUILD}s.

The id could be parsed from the \texttt{.SRCINFO}, which is a plain text file.
But VCS packages don't have up-to-date version information in their \texttt{PKGBUILD}, which means that it must be interpreted; This is annoying, but we only source the \texttt{PKGBUILD} in a \texttt{firejail} sandbox to minimize the inherent risk of executing foreign turing-complete code.
This allows us to get an accurate ID for VCS packages, but also to include the actual sources in the hash, thereby compensating for the lack of hashes in the \texttt{PKGBUILD} of VCS packages.

The \texttt{PKGBUILD} is hashed after stripping it's comments, and VCS sources, if they exist, are hashed using \texttt{find}.
Finally, all hashes are combined by another call to the hash command.
Currently, \texttt{sha256sum} is used for it's good speed and security.

\subsubsection{aursec-verify-hashes}
This tool is not very interesting; It simply fetches the current consensus for every package ID on \texttt{stdin}, computes whether it matches with the locally computed hash, and appends that data to the output stream.
Doing this in a separate pipeline step is very worth it because requests from the blockchain are comparatively slow.
